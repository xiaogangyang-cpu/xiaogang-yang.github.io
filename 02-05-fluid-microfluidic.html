<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>微流控芯片工程思维阶梯：层流之径</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* CSS样式优化 */
        :root {
            --primary-color: #0a1f44;
            --secondary-color: #00d4ff;
            --accent-color: #7b42f6;
            --success-color: #00e676;
            --warning-color: #ff9100;
            --danger-color: #ff4081;
            --dark-bg: #0c1220;
            --card-bg: rgba(18, 28, 52, 0.9);
            --text-color: #e0e0ff;
            --text-secondary: #a0a8d6;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: var(--dark-bg);
            color: var(--text-color);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(28, 58, 173, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(123, 66, 246, 0.1) 0%, transparent 20%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 50px;
        }
        
        header {
            text-align: center;
            padding: 10px 0;
            position: relative;
            margin-bottom: 5px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .logo-icon {
            font-size: 2rem;
            color: var(--secondary-color);
            text-shadow: 0 0 15px rgba(0, 212, 255, 0.7);
        }
        
        h1 {
            font-size: 2rem;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            letter-spacing: 1px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            max-width: 1200px;
            margin: 0 auto 10px;
            line-height: 1.2;
        }
        
        .tagline {
            display: inline-block;
            padding: 8px 20px;
            background: rgba(10, 31, 68, 0.7);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 30px;
            font-size: 0.95rem;
            color: var(--secondary-color);
            margin-top: -15px;
        }
        
        .game-container {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .level-content {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 212, 255, 0.1);
            margin-bottom: 10px;
            min-height: 500px;
        }
        
        .level-header {
            display: none;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        }
        
        .level-title {
            font-size: 1.8rem;
            color: var(--secondary-color);
        }
        
        .level-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
        }
        
        .challenge-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }
        
        .parameter-controls, .simulation-view {
            background: rgba(12, 18, 32, 0.7);
            border-radius: 10px;
            padding: 10px;
            border: 1px solid rgba(0, 212, 255, 0.1);
        }
        
        .section-title {
            font-size: 1.2rem;
            color: var(--secondary-color);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .param-group {
            margin-bottom: 20px;
        }
        
        .param-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }
        
        .param-value {
            color: var(--secondary-color);
            font-weight: 600;
        }
        
        .slider-container {
            width: 100%;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--secondary-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }
        
        .ai-guidance {
            background: rgba(10, 25, 47, 0.9);
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid var(--accent-color);
            margin-top: 15px;
        }
        
        .ai-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .ai-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-color), #3a0ca3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }
        
        .ai-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--secondary-color);
        }
        
        .ai-role {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .ai-message {
            line-height: 1.7;
            color: var(--text-color);
        }
        
        .highlight {
            color: var(--secondary-color);
            background: rgba(0, 212, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .simulation-view {
            position: relative;
            overflow: hidden;
        }
        
        .chip-container {
            width: 100%;
            height: 300px;
            background: rgba(5, 10, 25, 0.8);
            border-radius: 8px;
            position: relative;
            margin-bottom: 20px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            overflow: hidden;
        }
        
        .results-panel {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 5px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 212, 255, 0.1);
            display: flex;
            flex-direction: column;
            height: fit-content;
            min-height: 300px;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .results-title {
            font-size: 1.2rem;
            color: var(--secondary-color);
        }
        
        .results-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .result-item {
            background: rgba(12, 18, 32, 0.7);
            padding: 10px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .result-item.laminar {
            border-left-color: var(--success-color);
        }
        
        .result-item.turbulent {
            border-left-color: var(--danger-color);
        }
        
        .result-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .result-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-color);
        }
        
        .result-unit {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-left: 3px;
        }
        
        .right-ai-guidance {
            background: rgba(10, 25, 47, 0.9);
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid var(--accent-color);
            margin-top: auto;
        }
        
        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            margin-bottom: 40px;
        }
        
        .btn {
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-color), #3a0ca3);
            color: white;
        }
        
        .btn-secondary {
            background: rgba(0, 212, 255, 0.1);
            color: var(--secondary-color);
            border: 1px solid rgba(0, 212, 255, 0.3);
        }
        
        .btn-success {
            background: linear-gradient(135deg, var(--success-color), #00b248);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, var(--warning-color), #ff6d00);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* 测试报告容器 - 增强版 */
        .test-container {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 10px;
            margin-top: 15px;
            border: 1px solid rgba(0, 212, 255, 0.1);
        }
        
        .test-header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .test-title {
            font-size: 2.0rem;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 5px;
        }
        
        .test-subtitle {
            color: var(--text-secondary);
            font-size: 1.0rem;
        }
        
        .certificate-badge {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            background: linear-gradient(135deg, rgba(10, 31, 68, 0.9), rgba(123, 66, 246, 0.2));
            border-radius: 15px;
            border: 2px solid rgba(0, 212, 255, 0.3);
        }
        
        .certificate-icon {
            font-size: 2.5rem;
            color: var(--secondary-color);
            margin-bottom: 5px;
        }
        
        .certificate-title {
            font-size: 1.5rem;
            color: var(--secondary-color);
            margin-bottom: 5px;
        }
        
        .certificate-level {
            font-size: 1.8rem;
            font-weight: 800;
            background: linear-gradient(90deg, #ffd700, #ff9100);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .certificate-description {
            color: var(--text-secondary);
            max-width: 900px;
            margin: 0 auto;
            line-height: 1.2;
        }
        
        .test-results {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .test-result-item {
            background: rgba(12, 18, 32, 0.7);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            border-top: 4px solid;
        }
        
        .test-result-item.laminar {
            border-top-color: var(--success-color);
        }
        
        .test-result-item.turbulent {
            border-top-color: var(--warning-color);
        }
        
        .test-result-item.chaos {
            border-top-color: var(--accent-color);
        }
        
        .test-result-label {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        
        .test-result-value {
            font-size: 1.6rem;
            font-weight: 800;
            color: var(--text-color);
        }
        
        .test-result-score {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .test-summary-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .test-summary {
            background: rgba(10, 25, 47, 0.9);
            border-radius: 10px;
            padding: 25px;
            border-left: 4px solid var(--accent-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .test-summary h3 {
            color: var(--secondary-color);
            margin-bottom: 20px;
            font-size: 1.4rem;
        }
        
        .test-summary p {
            line-height: 1.7;
            color: var(--text-color);
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .test-summary .highlight {
            font-size: 1.2rem;
            padding: 4px 8px;
        }
        
        .test-radar-container {
            background: rgba(12, 18, 32, 0.7);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .test-radar-container canvas {
            flex: 1;
            width: 100% !important;
            height: auto !important;
        }
        
        .next-steps {
            margin-top: 40px;
            padding-top: 25px;
            border-top: 1px solid rgba(0, 212, 255, 0.1);
        }
        
        .next-steps h3 {
            color: var(--secondary-color);
            margin-bottom: 20px;
            font-size: 1.4rem;
        }
        
        .next-steps-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        
        .next-step-item {
            background: rgba(12, 18, 32, 0.7);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid var(--accent-color);
        }
        
        .next-step-title {
            color: var(--secondary-color);
            font-size: 1.2rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .next-step-desc {
            color: var(--text-secondary);
            line-height: 1.6;
        }
        
        .reynolds-warning {
            background: rgba(255, 64, 129, 0.1);
            border: 1px solid var(--danger-color);
            border-radius: 8px;
            padding: 10px 15px;
            margin-top: 10px;
            display: none;
        }
        
        .reynolds-warning.show {
            display: block;
        }
        
        .competency-profile {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 10px;
            margin-top: 20px;
            border: 1px solid rgba(0, 212, 255, 0.1);
        }
        
        .profile-title {
            text-align: center;
            font-size: 1.8rem;
            color: var(--secondary-color);
            margin-bottom: 10px;
        }
        
        .profile-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        
        .profile-table th, .profile-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 212, 255, 0.1);
        }
        
        .profile-table th {
            color: var(--secondary-color);
            font-weight: 600;
            font-size: 1.0rem;
        }
        
        .profile-table tr:last-child td {
            border-bottom: none;
        }
        
        .score-value {
            font-weight: 700;
            font-size: 1.0rem;
        }
        
        .score-excellent {
            color: var(--success-color);
        }
        
        .score-good {
            color: #4fc3f7;
        }
        
        .score-fair {
            color: var(--warning-color);
        }
        
        .score-poor {
            color: var(--danger-color);
        }
        
        .radar-chart-container {
            width: 100%;
            height: 300px;
            position: relative;
        }
        
        .recommendations {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 212, 255, 0.1);
        }
        
        .recommendations h3 {
            color: var(--secondary-color);
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .recommendations ul {
            padding-left: 20px;
            line-height: 1.7;
        }
        
        .recommendations li {
            margin-bottom: 10px;
            color: var(--text-secondary);
        }
        
        footer {
            text-align: center;
            padding: 30px 0;
            margin-top: 50px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            border-top: 1px solid rgba(0, 212, 255, 0.1);
        }
        
        /* 结果导航按钮 */
        .results-nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .nav-section {
            display: none;
        }
        
        .nav-section.active {
            display: block;
        }
        


        @media (max-width: 1024px) {
            .game-container {
                grid-template-columns: 1fr;
            }
            
            .challenge-area {
                grid-template-columns: 1fr;
            }
            
            .results-panel {
                height: auto;
                min-height: auto;
            }
            
            .test-summary-container {
                grid-template-columns: 1fr;
            }
            
            .next-steps-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            
            .container {
                padding: 20px;
            }
            
            .test-results {
                grid-template-columns: 1fr;
            }
            
            .control-buttons, .results-nav-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">
                    <i class="fas fa-microchip"></i>
                </div>
                <h1>微流控芯片工程思维阶梯</h1>
            </div>
            <p class="subtitle">基于数字孪生与多物理场耦合的微流控芯片设计挑战平台，通过层流控制挑战，培养您的数智工程素养与系统决策能力。</p>


        </header>
        
        <!-- 关卡主体部分 -->
        <div id="level-section" class="nav-section active">
            <div class="game-container">
                <div class="main-content">
                    <div class="level-content" id="level-content">
                        <!-- 关卡内容将通过JavaScript动态加载 -->
                    </div>
                    
                    <div class="control-buttons">
                        <button class="btn btn-primary" id="submit-level">
                            <i class="fas fa-check-circle"></i> 提交当前关卡
                        </button>
                        <button class="btn btn-secondary" id="reset-level">
                            <i class="fas fa-redo"></i> 重置参数
                        </button>
                    </div>
                </div>
                
                <!-- 右侧面板 -->
                <div class="results-panel">
                    <div class="results-header">
                        <h3 class="results-title">实时结果</h3>
                        <div class="level-indicator">
                            <i class="fas fa-layer-group"></i> <span id="current-level-indicator">层流之径</span>
                        </div>
                    </div>
                    
                    <div class="results-content" id="results-content">
                        <!-- 结果内容将通过JavaScript动态加载 -->
                    </div>
                    
                    <!-- 雷诺数警告 -->
                    <div class="reynolds-warning" id="reynolds-warning">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                            <i class="fas fa-exclamation-triangle" style="color: var(--warning-color);"></i>
                            <strong style="color: var(--warning-color);">雷诺数警告</strong>
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">
                            当前雷诺数已接近临界值(10)，流动可能向湍流转变。建议降低流速或增加通道尺寸。
                        </div>
                    </div>
                    
                    <!-- 右侧AI指导面板 -->
                    <div class="right-ai-guidance">
                        <div class="ai-header">
                            <div class="ai-avatar">
                                <i class="fas fa-robot"></i>
                            </div>
                            <div>
                                <div class="ai-name">AI思维阶梯</div>
                                <div class="ai-role">数智领航工程师</div>
                            </div>
                        </div>
                        <div class="ai-message" id="ai-message">
                            欢迎来到微流控芯片工程挑战！我是您的AI思维阶梯助手。在这一关中，您需要调整微通道几何形状和泵送压力，使流体在规定时间内到达反应区并保持层流状态。请注意观察雷诺数Re与流动阻力的关系。
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 能力画像部分 -->
        <div id="profile-section" class="nav-section">
            <div class="competency-profile" id="competency-profile">
                <h2 class="profile-title">数智工程能力画像</h2>
                <p class="test-subtitle" style="text-align: center; margin-bottom: 25px;">基于层流控制挑战中的决策路径分析</p>
                
                <table class="profile-table">
                    <thead>
                        <tr>
                            <th>能力维度</th>
                            <th>评估要点</th>
                            <th>得分</th>
                            <th>等级</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>建模准确度</td>
                            <td>系统边界与阻力判断</td>
                            <td class="score-value score-excellent" id="score-modeling">0/100</td>
                            <td class="score-excellent" id="grade-modeling">-</td>
                        </tr>
                        <tr>
                            <td>参数敏感性</td>
                            <td>雷诺数控制能力</td>
                            <td class="score-value score-good" id="score-sensitivity">0/100</td>
                            <td class="score-good" id="grade-sensitivity">-</td>
                        </tr>
                        <tr>
                            <td>决策权衡比</td>
                            <td>压力降与流量的工程取舍</td>
                            <td class="score-value score-fair" id="score-tradeoff">0/100</td>
                            <td class="score-fair" id="grade-tradeoff">-</td>
                        </tr>
                        <tr>
                            <td>系统认知</td>
                            <td>微尺度流动理解</td>
                            <td class="score-value score-good" id="score-system">0/100</td>
                            <td class="score-good" id="grade-system">-</td>
                        </tr>
                        <tr>
                            <td>创新思维</td>
                            <td>通道优化设计</td>
                            <td class="score-value score-excellent" id="score-innovation">0/100</td>
                            <td class="score-excellent" id="grade-innovation">-</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="radar-chart-container">
                    <canvas id="radarChart"></canvas>
                </div>
                
                <div class="recommendations">
                    <h3><i class="fas fa-lightbulb"></i> 改进建议</h3>
                    <ul id="recommendations-list">
                        <li>在层流控制中，可进一步优化通道高宽比以降低临界雷诺数下的压降</li>
                        <li>建议增加对微流控尺度下雷诺数非线性响应的理解</li>
                        <li>学习如何平衡流动时间与系统能耗的关系</li>
                        <li>建议深入学习亚微米级约束下的传质动力学，提升多参数耦合分析能力</li>
                    </ul>
                </div>
                
                <div class="results-nav-buttons">
                    <button class="btn btn-warning" id="go-to-report">
                        <i class="fas fa-arrow-down"></i> 查看工程师评级
                    </button>
                    <button class="btn btn-secondary" id="back-to-level">
                        <i class="fas fa-arrow-left"></i> 返回关卡
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 测试报告部分 -->
        <div id="report-section" class="nav-section">
            <div class="test-container" id="test-container">
                <div class="test-header">
                    <h2 class="test-title">微流控芯片工程能力综合测试报告</h2>
                    <p class="test-subtitle">基于层流控制挑战的全面评估与工程师等级认证</p>
                </div>
                
                <div class="certificate-badge">
                    <div class="certificate-icon">
                        <i class="fas fa-award"></i>
                    </div>
                    <h3 class="certificate-title">微流控芯片工程能力认证</h3>
                    <div class="certificate-level" id="engineer-level">见习工程师</div>
                    <p class="certificate-description" id="certificate-description">
                        此认证证明持有人已掌握微流控芯片层流控制的基本概念，需要在指导下完成设计任务。
                    </p>
                </div>
                
                <div class="test-results">
                    <div class="test-result-item laminar">
                        <div class="test-result-label">层流控制能力</div>
                        <div class="test-result-value" id="test-laminar">55</div>
                        <div class="test-result-score">分</div>
                    </div>
                    <div class="test-result-item turbulent">
                        <div class="test-result-label">雷诺数控制</div>
                        <div class="test-result-value" id="test-reynolds">55</div>
                        <div class="test-result-score">分</div>
                    </div>
                    <div class="test-result-item chaos">
                        <div class="test-result-label">参数优化</div>
                        <div class="test-result-value" id="test-optimization">55</div>
                        <div class="test-result-score">分</div>
                    </div>
                </div>
                
                <!-- 蛛网图和综合评估并排展示 -->
                <div class="test-summary-container">
                    <div class="test-radar-container">
                        <canvas id="testRadarChart"></canvas>
                    </div>
                    
                    <div class="test-summary">
                        <h3><i class="fas fa-chart-bar"></i> 综合评估</h3>
                        <p>总分：<span class="highlight" id="total-score">165</span> / 500</p>
                        <p>平均分：<span class="highlight" id="average-score">55</span></p>
                        <p>雷诺数控制表现：<span class="highlight" id="reynolds-performance">合格</span></p>
                        <p>流动状态控制：<span class="highlight" id="flow-performance">合格</span></p>
                        <p>工程权衡能力：<span class="highlight" id="tradeoff-performance">合格</span></p>
                    </div>
                </div>
                
                <div class="next-steps">
                    <h3><i class="fas fa-graduation-cap"></i> 后续学习建议</h3>
                    <div class="next-steps-grid">
                        <div class="next-step-item">
                            <h4 class="next-step-title"><i class="fas fa-water"></i> 深入学习CFD</h4>
                            <p class="next-step-desc">建议学习计算流体动力学(CFD)高级课程，掌握更精确的微尺度流动模拟方法，特别是层流与湍流转捩理论。</p>
                        </div>
                        <div class="next-step-item">
                            <h4 class="next-step-title"><i class="fas fa-project-diagram"></i> 微结构设计</h4>
                            <p class="next-step-desc">进一步研究微流控芯片的拓扑优化，探索新型流动控制结构与混合技术，特别是层流控制器的设计原理。</p>
                        </div>
                        <div class="next-step-item">
                            <h4 class="next-step-title"><i class="fas fa-cogs"></i> 多物理场耦合</h4>
                            <p class="next-step-desc">学习微尺度下流动、传热、传质的多物理场耦合分析，提升复杂微流控系统的设计能力。</p>
                        </div>
                        <div class="next-step-item">
                            <h4 class="next-step-title"><i class="fas fa-robot"></i> 数字孪生技术</h4>
                            <p class="next-step-desc">探索基于数字孪生的微流控系统优化方法，实现虚拟仿真与实验验证的闭环设计流程。</p>
                        </div>
                    </div>
                </div>
                
                <div class="results-nav-buttons">
                    <button class="btn btn-success" id="restart-exploration">
                        <i class="fas fa-redo"></i> 重新探索关卡
                    </button>
                    <button class="btn btn-secondary" id="back-to-profile">
                        <i class="fas fa-arrow-left"></i> 返回能力画像
                    </button>
                </div>
            </div>
        </div>
        

<!-- 底部信息栏 -->
<div style="
    text-align: center;
    padding: 20px 30px;
    margin-top: 40px;
    color: #e6f7ff;
    font-size: 0.9rem;
    border-top: 2px solid rgba(0, 180, 255, 0.5);
    background: linear-gradient(135deg, rgba(10, 15, 43, 0.95), rgba(18, 26, 58, 0.9));
    border-radius: 15px 15px 0 0;
    box-shadow: 0 -10px 30px rgba(0, 180, 255, 0.1);
    position: relative;
    overflow: hidden;
    /* 新增以下，确保完全宽度 */
    box-sizing: border-box;
    width: 100%;
    max-width: none;
">    <div style="position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #00b4ff, #6c8cff, #00b4ff);"></div>
        
    <p style="font-size: 1.1rem; font-weight: bold; margin-bottom: 15px; color: #00b4ff;">
微流控芯片工程思维阶梯© 2025  | 数智工程能力评估系统 | 版本1.0  |  
    <style="margin-bottom: 12px; color: #cbd5e1;">
        <strong>邮箱:</strong> xgyanger@qq.com
    <div style="margin-top: 15px;">
        <span style="color: #ffcc00; font-weight: bold; font-size: 1rem;">
            版权©2025 AIknow. 保留所有权利 | Copyright ©2025 AIknow. All rights reserved.
        </span>
    </div>
            </p>
        </footer>
    </div>

    <script>
        // 游戏状态管理
        const gameState = {
            currentLevel: 1,
            currentSection: "level", // level, profile, report
            level1: {
                title: "层流之径",
                subtitle: "The Laminar Path",
                completed: false,
                params: {
                    length: 10000,    // 10000 μm = 10 mm
                    width: 200,       // 200 μm
                    height: 50,       // 50 μm
                    pressure: 10,     // 10 kPa
                    density: 1.0,     // g/cm³
                    viscosity: 1.0,   // cP
                    flowRate: 0.1     // μL/min
                },
                results: {
                    reynolds: 0.15,    // 雷诺数
                    pressureDrop: 2.5, // kPa
                    flowTime: 8.3,     // 秒
                    flowResistance: 15.2,
                    status: "层流"
                },
                aiMessage: "欢迎来到第一关：层流之径！我是您的AI思维阶梯助手。您需要调整微通道几何形状和泵送压力，使流体在规定时间内到达反应区并保持层流状态。",
                detailedMessage: "您正在设计一个用于新能源电池的微流控电解液注入系统。请调整参数确保电解液在<span class='highlight'>8-12秒</span>内到达反应区，同时保持雷诺数Re < <span class='highlight'>10</span>以维持层流状态。"
            },
            scores: {
                modeling: 0,
                sensitivity: 0,
                tradeoff: 0,
                system: 0,
                innovation: 0
            },
            testScores: {
                laminar: 55,
                reynolds: 55,
                optimization: 55
            },
            animation: null
        };

        // DOM元素
        const levelContent = document.getElementById('level-content');
        const resultsContent = document.getElementById('results-content');
        const aiMessage = document.getElementById('ai-message');
        const submitBtn = document.getElementById('submit-level');
        const resetBtn = document.getElementById('reset-level');
        const competencyProfile = document.getElementById('competency-profile');
        const testContainer = document.getElementById('test-container');
        const currentLevelIndicator = document.getElementById('current-level-indicator');
        const reynoldsWarning = document.getElementById('reynolds-warning');
        
        // 导航按钮
        const goToReportBtn = document.getElementById('go-to-report');
        const backToLevelBtn = document.getElementById('back-to-level');
        const restartExplorationBtn = document.getElementById('restart-exploration');
        const backToProfileBtn = document.getElementById('back-to-profile');

        // 动画状态
        let flowParticles = [];
        let lastAnimationTime = 0;
        let particleEmitterTimer = 0;
        const EMIT_INTERVAL = 200;
        const MAX_PARTICLES = 60;

        // 初始化游戏
        function initGame() {
            loadLevel(1);
            initFlowVisualization();
            startAnimation();
            
            // 设置导航按钮事件
            setupNavigationEvents();
        }

        // 设置导航事件
        function setupNavigationEvents() {
            // 提交关卡后进入能力画像
            submitBtn.addEventListener('click', function() {
                gameState.level1.completed = true;
                calculateScores();
                showCompetencyProfile();
                switchSection('profile');
            });
            
            // 从能力画像进入报告
            goToReportBtn.addEventListener('click', function() {
                showTestReport();
                switchSection('report');
            });
            
            // 从能力画像返回关卡
            backToLevelBtn.addEventListener('click', function() {
                switchSection('level');
            });
            
            // 从报告返回能力画像
            backToProfileBtn.addEventListener('click', function() {
                switchSection('profile');
            });
            
            // 重新开始探索
            restartExplorationBtn.addEventListener('click', function() {
                resetGame();
                switchSection('level');
            });
            
            // 重置按钮
            resetBtn.addEventListener('click', function() {
                resetGame();
            });
        }

        // 切换部分
        function switchSection(section) {
            // 隐藏所有部分
            document.getElementById('level-section').classList.remove('active');
            document.getElementById('profile-section').classList.remove('active');
            document.getElementById('report-section').classList.remove('active');
            
            // 显示目标部分
            document.getElementById(`${section}-section`).classList.add('active');
            
            // 滚动到顶部
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            // 更新状态
            gameState.currentSection = section;
        }

        // 重置游戏
        function resetGame() {
            // 重置参数
            gameState.level1.params = {
                length: 10000,
                width: 100,
                height: 50,
                pressure: 10,
                density: 1.0,
                viscosity: 1.0,
                flowRate: 0.1
            };
            
            // 重置显示
            if (document.getElementById('length-slider')) {
                document.getElementById('length-slider').value = 10000;
                document.getElementById('width-slider').value = 100;
                document.getElementById('height-slider').value = 50;
                document.getElementById('pressure-slider').value = 10;
                document.getElementById('density-slider').value = 1.0;
                document.getElementById('viscosity-slider').value = 1.0;
                document.getElementById('flowrate-slider').value = 0.1;
                
                // 更新显示值
                document.getElementById('length-value').textContent = 10000;
                document.getElementById('width-value').textContent = 100;
                document.getElementById('height-value').textContent = 50;
                document.getElementById('pressure-value').textContent = 10;
                document.getElementById('density-value').textContent = 1.0;
                document.getElementById('viscosity-value').textContent = 1.0;
                document.getElementById('flowrate-value').textContent = 0.1;
                
                // 重新计算结果
                updateLevel1Results();
            }
            
            // 恢复AI消息
            aiMessage.innerHTML = formatAIMessage(gameState.level1.detailedMessage);
            
            // 重置完成状态
            gameState.level1.completed = false;
        }

        // 加载关卡内容
        function loadLevel(level) {
            const levelData = gameState.level1;
            currentLevelIndicator.textContent = `第一关: ${levelData.title}`;
            
            aiMessage.innerHTML = formatAIMessage(levelData.detailedMessage);
            levelContent.innerHTML = generateLevelContent();
            resultsContent.innerHTML = generateResultsContent();
            
            setupLevelEvents();
        }

        // 生成关卡内容
        function generateLevelContent() {
            const levelData = gameState.level1;
            
            return `
                <div class="level-header">
                    <div>
                        <h2 class="level-title">${levelData.title}</h2>
                        <p class="level-subtitle">${levelData.subtitle}</p>
                    </div>
                    <div class="level-indicator">
                        <i class="fas fa-tachometer-alt"></i> 雷诺数控制挑战
                    </div>
                </div>
                
                <div class="challenge-area">
                    <div class="parameter-controls">
                        <h3 class="section-title"><i class="fas fa-sliders-h"></i> 参数调整</h3>
                        
                        <div class="param-group">
                            <div class="param-label">
                                <span>通道长度 L (μm)</span>
                                <span class="param-value" id="length-value">${levelData.params.length}</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="500" max="20000" step="100" value="${levelData.params.length}" class="param-slider" id="length-slider">
                            </div>
                        </div>
                        
                        <div class="param-group">
                            <div class="param-label">
                                <span>通道宽度 w (μm)</span>
                                <span class="param-value" id="width-value">${levelData.params.width}</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="50" max="800" step="5" value="${levelData.params.width}" class="param-slider" id="width-slider">
                            </div>
                        </div>
                        
                        <div class="param-group">
                            <div class="param-label">
                                <span>通道高度 h (μm)</span>
                                <span class="param-value" id="height-value">${levelData.params.height}</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="20" max="500" step="5" value="${levelData.params.height}" class="param-slider" id="height-slider">
                            </div>
                        </div>
                        
                        <div class="param-group">
                            <div class="param-label">
                                <span>泵送压力 P (kPa)</span>
                                <span class="param-value" id="pressure-value">${levelData.params.pressure}</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="1" max="50" step="0.5" value="${levelData.params.pressure}" class="param-slider" id="pressure-slider">
                            </div>
                        </div>
                        
                        <div class="param-group">
                            <div class="param-label">
                                <span>流体密度 ρ (g/cm³)</span>
                                <span class="param-value" id="density-value">${levelData.params.density}</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="0.6" max="2" step="0.1" value="${levelData.params.density}" class="param-slider" id="density-slider">
                            </div>
                        </div>
                        
                        <div class="param-group">
                            <div class="param-label">
                                <span>流体粘度 μ (cP)</span>
                                <span class="param-value" id="viscosity-value">${levelData.params.viscosity}</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="0.2" max="5" step="0.1" value="${levelData.params.viscosity}" class="param-slider" id="viscosity-slider">
                            </div>
                        </div>
                    </div>
                    
                    <div class="simulation-view">
                        <h3 class="section-title"><i class="fas fa-water"></i> 流动模拟</h3>
                        <div class="chip-container" id="flow-visualization">
                            <!-- 流动可视化将通过JavaScript绘制 -->
                        </div>
                        <div class="param-group">
                            <div class="param-label">
                                <span>流量 Q (μL/min)</span>
                                <span class="param-value" id="flowrate-value">${levelData.params.flowRate}</span>
                            </div>
                            <div class="slider-container">
                                <input type="range" min="0.01" max="2000" step="0.01" value="${levelData.params.flowRate}" class="param-slider" id="flowrate-slider">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="ai-guidance">
                    <div class="ai-header">
                        <div class="ai-avatar">
                            <i class="fas fa-robot"></i>
                        </div>
                        <div>
                            <div class="ai-name">AI思维阶梯</div>
                            <div class="ai-role">雷诺数(Re)与流动阻力</div>
                        </div>
                    </div>
                    <div class="ai-message">
                        <strong>设计目标：</strong> 
                        1. 流动时间控制在 8-12 秒内<br>
                        2. 雷诺数 Re < 10 保持层流<br>
                        3. 压力降 ΔP 尽可能低<br><br>
                        
                        <strong>关键公式：</strong><br>
                        • 雷诺数: Re = ρ·v·D<sub>H</sub>/μ<br>
                        • 水力直径: D<sub>H</sub> = 2·w·h/(w+h)<br>
                        • 流动阻力: R<sub>f</sub> = 12·μ·L/(f·w<sup>3</sup>·h)<br>
                        • 压力降: ΔP = Q·R<sub>f</sub><br>
                    </div>
                </div>
            `;
        }

        // 生成结果内容
        function generateResultsContent() {
            const levelData = gameState.level1;
            const isLaminar = levelData.results.reynolds < 10;
            
            return `
                <div class="result-item ${isLaminar ? 'laminar' : 'turbulent'}">
                    <div class="result-label">雷诺数 Re</div>
                    <div class="result-value">${levelData.results.reynolds.toFixed(2)}</div>
                    <div class="result-unit">${isLaminar ? '(层流)' : '(湍流风险)'}</div>
                </div>
                <div class="result-item">
                    <div class="result-label">流动状态</div>
                    <div class="result-value">${levelData.results.status}</div>
                </div>
                <div class="result-item">
                    <div class="result-label">压力降 ΔP</div>
                    <div class="result-value">${levelData.results.pressureDrop.toFixed(1)}</div>
                    <div class="result-unit">kPa</div>
                </div>
                <div class="result-item">
                    <div class="result-label">流动时间</div>
                    <div class="result-value">${levelData.results.flowTime.toFixed(1)}</div>
                    <div class="result-unit">秒</div>
                </div>
            `;
        }

        // 格式化AI消息
        function formatAIMessage(message) {
            return message.replace(/\$(.*?)\$/g, '<span class="highlight">$1</span>');
        }

        // 设置事件监听
        function setupLevelEvents() {
            const sliders = document.querySelectorAll('.param-slider');
            
            sliders.forEach(slider => {
                slider.addEventListener('input', function() {
                    const paramId = this.id.replace('-slider', '');
                    const value = this.value;
                    
                    document.getElementById(`${paramId}-value`).textContent = value;
                    gameState.level1.params[paramId] = parseFloat(value);
                    
                    updateLevel1Results();
                });
            });
        }

        // 更新第一关结果
        function updateLevel1Results() {
            const params = gameState.level1.params;
            
            // 单位转换
            const length_m = params.length * 1e-6;
            const width_m = params.width * 1e-6;
            const height_m = params.height * 1e-6;
            
            // 计算水力直径
            const hydraulicDiameter = 2 * width_m * height_m / (width_m + height_m);
            const crossArea = width_m * height_m;
            const flowRate_SI = params.flowRate * 1e-9 / 60;
            const velocity = flowRate_SI / crossArea;
            const density_SI = params.density * 1000;
            const viscosity_SI = params.viscosity * 0.001;
            
            // 计算雷诺数
            const reynolds = (density_SI * velocity * hydraulicDiameter) / viscosity_SI;
            
            // 计算形状因子和流动阻力
            const aspectRatio = height_m / width_m;
            let shapeFactor = 1.0;
            
            if (aspectRatio < 1) {
                shapeFactor = (1 - 0.63 * aspectRatio) * (1 + aspectRatio) * (1 + aspectRatio);
            } else {
                const invAspectRatio = 1 / aspectRatio;
                shapeFactor = (1 - 0.63 * invAspectRatio) * (1 + invAspectRatio) * (1 + invAspectRatio);
            }
            
            const flowResistance = (12 * viscosity_SI * length_m) / 
                                  (shapeFactor * Math.pow(Math.min(width_m, height_m), 3) * Math.max(width_m, height_m));
            
            // 计算压力降和流动时间
            const pressureDrop_Pa = flowRate_SI * flowResistance;
            const pressureDrop_kPa = pressureDrop_Pa / 1000;
            const flowTime = length_m / velocity;
            
            // 确定流动状态
            let status = "层流";
            if (reynolds < 10) {
                status = "稳定层流";
            } else if (reynolds < 100) {
                status = "层流";
            } else if (reynolds < 2000) {
                status = "过渡流";
            } else {
                status = "湍流";
            }
            
            // 更新游戏状态
            gameState.level1.results.reynolds = reynolds;
            gameState.level1.results.pressureDrop = pressureDrop_kPa;
            gameState.level1.results.flowTime = flowTime;
            gameState.level1.results.flowResistance = flowResistance * 1e-12;
            gameState.level1.results.status = status;
            
            // 更新结果显示
            updateResultsDisplay();
            
            // 更新粒子速度
            updateParticleSpeeds(reynolds < 10, velocity * 1000);
            
            // 显示或隐藏雷诺数警告
            if (reynolds > 8 && reynolds < 15) {
                reynoldsWarning.classList.add('show');
                reynoldsWarning.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                        <i class="fas fa-exclamation-triangle" style="color: var(--warning-color);"></i>
                        <strong style="color: var(--warning-color);">雷诺数警告</strong>
                    </div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary);">
                        当前雷诺数 Re = ${reynolds.toFixed(2)}，接近微流控临界值(10)。
                    </div>
                `;
            } else if (reynolds >= 15) {
                reynoldsWarning.classList.add('show');
                reynoldsWarning.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                        <i class="fas fa-exclamation-circle" style="color: var(--danger-color);"></i>
                        <strong style="color: var(--danger-color);">湍流风险</strong>
                    </div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary);">
                        当前雷诺数 Re = ${reynolds.toFixed(2)} > 15，流动可能不稳定。
                    </div>
                `;
            } else {
                reynoldsWarning.classList.remove('show');
            }
        }

        // 更新结果显示
        function updateResultsDisplay() {
            resultsContent.innerHTML = generateResultsContent();
        }

        // 计算分数 - 调整为从较低水平开始
        function calculateScores() {
            const results = gameState.level1.results;
            const params = gameState.level1.params;
            
            // 1. 建模准确度分数 - 基础分设为50-65
            const targetTime = 10;
            const timeError = Math.abs(results.flowTime - targetTime);
            let modelingScore = 55; // 基础分
            if (timeError <= 1) modelingScore += 30 + Math.random() * 10;
            else if (timeError <= 2) modelingScore += 15 + Math.random() * 10;
            else if (timeError <= 3) modelingScore += 5 + Math.random() * 10;
            else modelingScore += Math.random() * 5;
            
            // 2. 参数敏感性分数
            const reynolds = results.reynolds;
            let sensitivityScore = 55; // 基础分
            if (reynolds < 5) sensitivityScore += 30 + Math.random() * 10;
            else if (reynolds < 8) sensitivityScore += 20 + Math.random() * 10;
            else if (reynolds < 10) sensitivityScore += 15 + Math.random() * 10;
            else if (reynolds < 15) sensitivityScore += 5 + Math.random() * 10;
            else sensitivityScore += Math.random() * 5;
            
            // 3. 决策权衡分数
            const pressurePerLength = results.pressureDrop / (params.length / 10000);
            let tradeoffScore = 55; // 基础分
            if (pressurePerLength < 0.2) tradeoffScore += 30 + Math.random() * 10;
            else if (pressurePerLength < 0.4) tradeoffScore += 20 + Math.random() * 10;
            else if (pressurePerLength < 0.6) tradeoffScore += 10 + Math.random() * 10;
            else tradeoffScore += Math.random() * 5;
            
            // 4. 系统认知分数
            const aspectRatio = params.height / params.width;
            const isOptimalAspect = aspectRatio > 0.4 && aspectRatio < 0.6;
            const isOptimalFlowRate = params.flowRate > 0.05 && params.flowRate < 0.5;
            let systemScore = 55; // 基础分
            if (isOptimalAspect && isOptimalFlowRate) systemScore += 30 + Math.random() * 10;
            else if (isOptimalAspect || isOptimalFlowRate) systemScore += 15 + Math.random() * 10;
            else systemScore += Math.random() * 5;
            
            // 5. 创新思维分数
            const isLaminar = results.reynolds < 10;
            const inTime = results.flowTime >= 8 && results.flowTime <= 12;
            let innovationScore = 55; // 基础分
            if (isLaminar && inTime && pressurePerLength < 0.3) innovationScore += 30 + Math.random() * 10;
            else if (isLaminar && inTime) innovationScore += 20 + Math.random() * 10;
            else if (isLaminar) innovationScore += 10 + Math.random() * 10;
            else innovationScore += Math.random() * 5;
            
            // 更新游戏状态分数
            gameState.scores.modeling = Math.min(100, Math.round(modelingScore));
            gameState.scores.sensitivity = Math.min(100, Math.round(sensitivityScore));
            gameState.scores.tradeoff = Math.min(100, Math.round(tradeoffScore));
            gameState.scores.system = Math.min(100, Math.round(systemScore));
            gameState.scores.innovation = Math.min(100, Math.round(innovationScore));
            
            // 计算测试分数 - 保证在合理范围内
            gameState.testScores.laminar = Math.min(100, Math.round((gameState.scores.modeling + gameState.scores.system) / 2));
            gameState.testScores.reynolds = Math.min(100, Math.round(gameState.scores.sensitivity));
            gameState.testScores.optimization = Math.min(100, Math.round((gameState.scores.tradeoff + gameState.scores.innovation) / 2));
        }

        // 显示能力画像
        function showCompetencyProfile() {
            // 更新分数显示
            document.getElementById('score-modeling').textContent = `${gameState.scores.modeling}/100`;
            document.getElementById('score-sensitivity').textContent = `${gameState.scores.sensitivity}/100`;
            document.getElementById('score-tradeoff').textContent = `${gameState.scores.tradeoff}/100`;
            document.getElementById('score-system').textContent = `${gameState.scores.system}/100`;
            document.getElementById('score-innovation').textContent = `${gameState.scores.innovation}/100`;
            
            // 更新等级显示
            document.getElementById('grade-modeling').textContent = getGrade(gameState.scores.modeling);
            document.getElementById('grade-modeling').className = getGradeClass(gameState.scores.modeling);
            
            document.getElementById('grade-sensitivity').textContent = getGrade(gameState.scores.sensitivity);
            document.getElementById('grade-sensitivity').className = getGradeClass(gameState.scores.sensitivity);
            
            document.getElementById('grade-tradeoff').textContent = getGrade(gameState.scores.tradeoff);
            document.getElementById('grade-tradeoff').className = getGradeClass(gameState.scores.tradeoff);
            
            document.getElementById('grade-system').textContent = getGrade(gameState.scores.system);
            document.getElementById('grade-system').className = getGradeClass(gameState.scores.system);
            
            document.getElementById('grade-innovation').textContent = getGrade(gameState.scores.innovation);
            document.getElementById('grade-innovation').className = getGradeClass(gameState.scores.innovation);
            
            // 初始化雷达图
            initRadarChart();
        }

        // 显示测试报告
        function showTestReport() {
            // 更新测试分数
            document.getElementById('test-laminar').textContent = gameState.testScores.laminar;
            document.getElementById('test-reynolds').textContent = gameState.testScores.reynolds;
            document.getElementById('test-optimization').textContent = gameState.testScores.optimization;
            
            // 计算总分和平均分
            const totalScore = gameState.testScores.laminar + gameState.testScores.reynolds + gameState.testScores.optimization;
            const averageScore = Math.round(totalScore / 3);
            
           document.getElementById('total-score').textContent = Math.round(totalScore * 5 / 3);
            document.getElementById('average-score').textContent = averageScore;
            
            // 确定工程师等级 - 从较低水平开始
            let engineerLevel = "见习工程师";
            let certificateDesc = "此认证证明持有人已掌握微流控芯片层流控制的基本概念，需要在指导下完成设计任务。";
            
            if (averageScore >= 90) {
                engineerLevel = "高级工程师";
                certificateDesc = "此认证证明持有人在微流控芯片层流控制方面具备卓越能力，能够处理复杂微流控系统设计与优化任务。";
            } else if (averageScore >= 80) {
                engineerLevel = "工程师";
                certificateDesc = "此认证证明持有人在微流控芯片层流控制方面具备良好能力，能够独立完成微流控芯片设计任务。";
            } else if (averageScore >= 70) {
                engineerLevel = "助理工程师";
                certificateDesc = "此认证证明持有人在微流控芯片层流控制方面具备基础能力，能够处理常规微流控芯片设计任务。";
            } else if (averageScore >= 60) {
                engineerLevel = "见习工程师";
                certificateDesc = "此认证证明持有人已掌握微流控芯片层流控制的基本概念，需要在指导下完成设计任务。";
            } else {
                engineerLevel = "入门学员";
                certificateDesc = "此认证证明持有人已初步了解微流控芯片层流控制的基本原理，需要进一步加强学习和实践。";
            }
            
            document.getElementById('engineer-level').textContent = engineerLevel;
            document.getElementById('certificate-description').textContent = certificateDesc;
            
            // 更新性能评估
            document.getElementById('reynolds-performance').textContent = 
                gameState.testScores.reynolds >= 80 ? "优秀" : 
                gameState.testScores.reynolds >= 70 ? "良好" :
                gameState.testScores.reynolds >= 60 ? "合格" : "需改进";
                
            document.getElementById('flow-performance').textContent = 
                gameState.testScores.laminar >= 80 ? "优秀" : 
                gameState.testScores.laminar >= 70 ? "良好" :
                gameState.testScores.laminar >= 60 ? "合格" : "需改进";
                
            document.getElementById('tradeoff-performance').textContent = 
                gameState.testScores.optimization >= 80 ? "优秀" : 
                gameState.testScores.optimization >= 70 ? "良好" :
                gameState.testScores.optimization >= 60 ? "合格" : "需改进";
            
            // 初始化测试雷达图
            initTestRadarChart();
        }

        // 获取等级
        function getGrade(score) {
            if (score >= 90) return "卓越";
            if (score >= 80) return "优秀";
            if (score >= 70) return "良好";
            if (score >= 60) return "合格";
            return "需改进";
        }

        // 获取等级类
        function getGradeClass(score) {
            if (score >= 90) return "score-excellent";
            if (score >= 80) return "score-good";
            if (score >= 70) return "score-fair";
            if (score >= 60) return "score-fair";
            return "score-poor";
        }

        // 初始化雷达图
        function initRadarChart() {
            const ctx = document.getElementById('radarChart').getContext('2d');
            
            if (window.radarChartInstance) {
                window.radarChartInstance.destroy();
            }
            
            window.radarChartInstance = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['建模准确度', '参数敏感性', '决策权衡比', '系统认知', '创新思维'],
                    datasets: [{
                        label: '能力评估',
                        data: [
                            gameState.scores.modeling,
                            gameState.scores.sensitivity,
                            gameState.scores.tradeoff,
                            gameState.scores.system,
                            gameState.scores.innovation
                        ],
                        backgroundColor: 'rgba(0, 212, 255, 0.2)',
                        borderColor: 'rgba(0, 212, 255, 1)',
                        pointBackgroundColor: 'rgba(0, 212, 255, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(0, 212, 255, 1)',
                        borderWidth: 2,
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: { color: 'rgba(255, 255, 255, 0.1)' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            pointLabels: { 
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: { size: 14 }
                            },
                            ticks: {
                                backdropColor: 'transparent',
                                color: 'rgba(255, 255, 255, 0.5)',
                                font: { size: 12 },
                                suggestedMin: 0,
                                suggestedMax: 100
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: { size: 18}
                            }
                        }
                    }
                }
            });
        }

        // 初始化测试雷达图
        function initTestRadarChart() {
            const ctx = document.getElementById('testRadarChart').getContext('2d');
            
            if (window.testRadarChartInstance) {
                window.testRadarChartInstance.destroy();
            }
            
            window.testRadarChartInstance = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['层流控制', '雷诺数控制', '参数优化', '工程权衡', '系统设计'],
                    datasets: [{
                        label: '测试评估',
                        data: [
                            gameState.testScores.laminar,
                            gameState.testScores.reynolds,
                            gameState.testScores.optimization,
                            gameState.scores.tradeoff,
                            gameState.scores.system
                        ],
                        backgroundColor: 'rgba(123, 66, 246, 0.2)',
                        borderColor: 'rgba(123, 66, 246, 1)',
                        pointBackgroundColor: 'rgba(123, 66, 246, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(123, 66, 246, 1)',
                        borderWidth: 2,
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: { color: 'rgba(255, 255, 255, 0.1)' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            pointLabels: { 
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: { size: 14 }
                            },
                            ticks: {
                                backdropColor: 'transparent',
                                color: 'rgba(255, 255, 255, 0.5)',
                                font: { size: 12 },
                                suggestedMin: 0,
                                suggestedMax: 100
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: { size: 15 }
                            }
                        }
                    }
                }
            });
        }

        // 以下为动画相关函数，保持不变
        function initFlowVisualization() {
            const container = document.getElementById('flow-visualization');
            if (!container) return;
            
            container.innerHTML = '';
            const canvas = document.createElement('canvas');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            container.appendChild(canvas);
            
            flowParticles = [];
            createFlowParticles(canvas.width, canvas.height);
        }

        function createFlowParticles(width, height) {
            const channelWidth = width * 0.7;
            const channelHeight = height * 0.5;
            const channelX = width * 0.15;
            const channelY = height * 0.3;
            
            const initialCount = 25;
            for (let i = 0; i < initialCount; i++) {
                const progress = (i / initialCount) * 0.8 + 0.1;
                const xPos = channelX + channelWidth * progress;
                
                flowParticles.push({
                    x: xPos,
                    y: channelY + channelHeight * 0.1 + Math.random() * channelHeight * 0.8,
                    size: 1.5 + Math.random() * 2,
                    baseSpeed: 0.8 + Math.random() * 1.2,
                    color: `rgba(0, 212, 255, ${0.6 + Math.random() * 0.4})`,
                    trail: [],
                    maxTrailLength: 8 + Math.floor(Math.random() * 6),
                    direction: 1,
                    life: 1.0,
                    age: Math.random() * 5,
                    velocityScale: 1.0,
                    isActive: true
                });
            }
        }

        function emitParticles(width, height) {
            const channelWidth = width * 0.7;
            const channelHeight = height * 0.5;
            const channelX = width * 0.15;
            const channelY = height * 0.3;
            
            if (flowParticles.length < MAX_PARTICLES) {
                const emitCount = 1 + Math.floor(Math.random() * 2);
                
                for (let i = 0; i < emitCount; i++) {
                    flowParticles.push({
                        x: channelX - 10 - Math.random() * 20,
                        y: channelY + channelHeight * 0.1 + Math.random() * channelHeight * 0.8,
                        size: 1.5 + Math.random() * 2,
                        baseSpeed: 0.8 + Math.random() * 1.2,
                        color: `rgba(0, 212, 255, ${0.6 + Math.random() * 0.4})`,
                        trail: [],
                        maxTrailLength: 8 + Math.floor(Math.random() * 6),
                        direction: 1,
                        life: 2.0,
                        age: 0,
                        velocityScale: 1.0,
                        isActive: true
                    });
                }
            }
        }

        function startAnimation() {
            if (gameState.animation) {
                cancelAnimationFrame(gameState.animation);
            }
            
            function animate() {
                updateFlowAnimation();
                gameState.animation = requestAnimationFrame(animate);
            }
            
            animate();
        }

        function updateFlowAnimation() {
            const container = document.getElementById('flow-visualization');
            if (!container) return;
            
            const canvas = container.querySelector('canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const isLaminar = gameState.level1.results.reynolds < 10;
            drawFlowChip(ctx, width, height, isLaminar);
            
            const now = Date.now();
            particleEmitterTimer += lastAnimationTime ? (now - lastAnimationTime) : 0;
            lastAnimationTime = now;
            
            if (particleEmitterTimer > EMIT_INTERVAL) {
                emitParticles(width, height);
                particleEmitterTimer = 0;
            }
            
            const deltaTime = Math.min(1, 16 / (1000 / 60));
            const channelWidth = width * 0.7;
            const channelHeight = height * 0.5;
            const channelX = width * 0.15;
            const channelY = height * 0.3;
            
            const isLaminarFlow = gameState.level1.results.reynolds < 10;
            let baseSpeedMultiplier = isLaminarFlow ? 1.2 : 3.0;
            
            const reynolds = gameState.level1.results.reynolds;
            if (reynolds > 5 && reynolds < 15) {
                baseSpeedMultiplier = 1.8;
            } else if (reynolds >= 15) {
                baseSpeedMultiplier = 2.5;
            }
            
            for (let i = flowParticles.length - 1; i >= 0; i--) {
                const particle = flowParticles[i];
                
                if (!particle.isActive) {
                    flowParticles.splice(i, 1);
                    continue;
                }
                
                particle.age += deltaTime * 0.05;
                let speed = particle.baseSpeed * baseSpeedMultiplier;
                
                if (!isLaminarFlow) {
                    const turbulence = 0.3 + Math.sin(particle.age * 2) * 0.2;
                    speed *= (1 + turbulence);
                }
                
                particle.x += speed * deltaTime * particle.direction;
                
                if (particle.x > channelX + channelWidth + 30) {
                    particle.x = channelX - 20 - Math.random() * 15;
                    particle.y = channelY + channelHeight * 0.1 + Math.random() * channelHeight * 0.8;
                    particle.trail = [];
                    particle.age = 0;
                    
                    if (!isLaminarFlow) {
                        particle.y += (Math.random() - 0.5) * channelHeight * 0.3;
                    }
                }
                
                let yPos = particle.y;
                if (!isLaminarFlow) {
                    const waveAmplitude = channelHeight * 0.15;
                    const waveFrequency = 0.03;
                    yPos += Math.sin(particle.x * waveFrequency + particle.age * 3) * waveAmplitude;
                    yPos = Math.max(channelY + 2, Math.min(channelY + channelHeight - 2, yPos));
                }
                
                particle.trail.push({
                    x: particle.x, 
                    y: yPos, 
                    life: particle.life,
                    size: particle.size * (0.7 + Math.random() * 0.3)
                });
                
                if (particle.trail.length > particle.maxTrailLength) {
                    particle.trail.shift();
                }
                
                particle.trail.forEach(point => {
                    point.life -= 0.015;
                });
                
                particle.trail = particle.trail.filter(point => point.life > 0.1);
                
                for (let j = 0; j < particle.trail.length - 1; j++) {
                    const point1 = particle.trail[j];
                    const point2 = particle.trail[j + 1];
                    const alpha = point1.life * 0.7;
                    
                    const gradient = ctx.createLinearGradient(
                        point1.x, point1.y, 
                        point2.x, point2.y
                    );
                    
                    gradient.addColorStop(0, `rgba(0, 212, 255, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(0, 212, 255, ${alpha * 0.4})`);
                    
                    ctx.beginPath();
                    ctx.moveTo(point1.x, point1.y);
                    ctx.lineTo(point2.x, point2.y);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = point1.size * 0.9;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
                
                ctx.beginPath();
                ctx.arc(particle.x, yPos, particle.size, 0, Math.PI * 2);
                let particleAlpha = 0.8 + Math.sin(particle.age * 2) * 0.1;
                ctx.fillStyle = `rgba(0, 212, 255, ${particleAlpha})`;
                ctx.fill();
                
                const glowRadius = particle.size * 2.5;
                const gradient = ctx.createRadialGradient(
                    particle.x, yPos, 0,
                    particle.x, yPos, glowRadius
                );
                gradient.addColorStop(0, `rgba(0, 212, 255, 0.3)`);
                gradient.addColorStop(1, `rgba(0, 212, 255, 0)`);
                
                ctx.beginPath();
                ctx.arc(particle.x, yPos, glowRadius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                if (!isLaminarFlow && Math.random() < 0.05) {
                    ctx.beginPath();
                    ctx.arc(particle.x, yPos, particle.size * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 100, 100, 0.3)`;
                    ctx.fill();
                }
            }
            
            if (flowParticles.length < 15) {
                const needed = 25 - flowParticles.length;
                for (let i = 0; i < needed; i++) {
                    flowParticles.push({
                        x: channelX + Math.random() * channelWidth * 0.3,
                        y: channelY + channelHeight * 0.1 + Math.random() * channelHeight * 0.8,
                        size: 1.5 + Math.random() * 2,
                        baseSpeed: 0.8 + Math.random() * 1.2,
                        color: `rgba(0, 212, 255, ${0.6 + Math.random() * 0.4})`,
                        trail: [],
                        maxTrailLength: 8 + Math.floor(Math.random() * 6),
                        direction: 1,
                        life: 1.0,
                        age: Math.random() * 5,
                        velocityScale: 1.0,
                        isActive: true
                    });
                }
            }
        }

        function drawFlowChip(ctx, width, height, isLaminar) {
            ctx.fillStyle = 'rgba(5, 10, 25, 1)';
            ctx.fillRect(0, 0, width, height);
            
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, width - 20, height - 20);
            
            ctx.fillStyle = 'rgba(0, 212, 255, 0.7)';
            ctx.font = '14px Arial';
            ctx.fillText('微流控芯片 - 直通道层流', 20, 30);
            
            const channelWidth = width * 0.7;
            const channelHeight = height * 0.5;
            const channelX = width * 0.15;
            const channelY = height * 0.3;
            
            const channelGradient = ctx.createLinearGradient(
                channelX, channelY, 
                channelX, channelY + channelHeight
            );
            
            if (isLaminar) {
                channelGradient.addColorStop(0, 'rgba(10, 40, 80, 0.9)');
                channelGradient.addColorStop(0.5, 'rgba(8, 35, 70, 0.9)');
                channelGradient.addColorStop(1, 'rgba(5, 20, 50, 0.9)');
            } else {
                channelGradient.addColorStop(0, 'rgba(20, 20, 60, 0.9)');
                channelGradient.addColorStop(0.5, 'rgba(15, 15, 50, 0.9)');
                channelGradient.addColorStop(1, 'rgba(10, 10, 40, 0.9)');
            }
            
            ctx.fillStyle = channelGradient;
            ctx.fillRect(channelX, channelY, channelWidth, channelHeight);
            
            if (isLaminar) {
                ctx.strokeStyle = 'rgba(0, 230, 118, 0.8)';
            } else {
                ctx.strokeStyle = 'rgba(255, 64, 129, 0.8)';
            }
            
            ctx.lineWidth = 3;
            ctx.strokeRect(channelX, channelY, channelWidth, channelHeight);
            
            if (isLaminar) {
                ctx.strokeStyle = 'rgba(0, 230, 118, 0.2)';
                ctx.lineWidth = 1;
                
                const flowLines = 6;
                for (let i = 1; i <= flowLines; i++) {
                    const y = channelY + (i * channelHeight / (flowLines + 1));
                    
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(channelX, y);
                    ctx.lineTo(channelX + channelWidth, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            } else {
                ctx.strokeStyle = 'rgba(255, 64, 129, 0.15)';
                ctx.lineWidth = 1;
                
                const waveCount = 8;
                for (let i = 1; i <= waveCount; i++) {
                    const baseY = channelY + (i * channelHeight / (waveCount + 1));
                    
                    ctx.beginPath();
                    ctx.moveTo(channelX, baseY);
                    
                    const segments = 20;
                    for (let j = 0; j <= segments; j++) {
                        const x = channelX + (j * channelWidth / segments);
                        const amplitude = 3;
                        const frequency = 0.08;
                        const y = baseY + Math.sin(x * frequency + i) * amplitude;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.stroke();
                }
            }
            
            const inletHeight = channelHeight * 1;
            const inletY = channelY + (channelHeight - inletHeight) / 2;
            
            const inletGradient = ctx.createLinearGradient(
                channelX - 15, inletY,
                channelX, inletY + inletHeight
            );
            inletGradient.addColorStop(0, 'rgba(0, 212, 255, 0.1)');
            inletGradient.addColorStop(1, 'rgba(0, 212, 255, 0.4)');
            
            ctx.fillStyle = inletGradient;
            ctx.fillRect(channelX - 15, inletY, 15, inletHeight);
            
            const outletGradient = ctx.createLinearGradient(
                channelX + channelWidth, inletY,
                channelX + channelWidth + 15, inletY + inletHeight
            );
            outletGradient.addColorStop(0, 'rgba(0, 212, 255, 0.4)');
            outletGradient.addColorStop(1, 'rgba(0, 212, 255, 0.1)');
            
            ctx.fillStyle = outletGradient;
            ctx.fillRect(channelX + channelWidth, inletY, 15, inletHeight);
            
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.6)';
            ctx.lineWidth = 2;
            ctx.strokeRect(channelX - 15, inletY, 15, inletHeight);
            ctx.strokeRect(channelX + channelWidth, inletY, 15, inletHeight);
            
            ctx.fillStyle = 'rgba(0, 212, 255, 0.9)';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('入口', channelX - 30, channelY + channelHeight / 2 + 5);
            ctx.fillText('出口', channelX + channelWidth + 20, channelY + channelHeight / 2 + 5);
            
            drawArrow(ctx, channelX + channelWidth - 25, channelY + channelHeight / 2, 25, 0);
            
            ctx.fillStyle = isLaminar ? 'rgba(0, 230, 118, 0.9)' : 'rgba(255, 64, 129, 0.9)';
            ctx.font = 'bold 11px Arial';
            ctx.fillText(
                isLaminar ? '层流状态' : '湍流风险', 
                channelX + channelWidth / 2 - 25, 
                channelY + channelHeight + 15
            );
        }

        function updateParticleSpeeds(isLaminar, velocity) {
            const baseSpeedMultiplier = isLaminar ? 1.2 : 2.5;
            const speedFactor = Math.min(2.5, Math.max(0.8, velocity / 0.3));
            
            flowParticles.forEach(particle => {
                particle.baseSpeed = (0.8 + Math.random() * 1.2) * baseSpeedMultiplier * speedFactor;
            });
        }

        function drawArrow(ctx, x, y, length, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(length, 0);
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.9)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(length, 0);
            ctx.lineTo(length - 10, -5);
            ctx.lineTo(length - 10, 5);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 212, 255, 0.9)';
            ctx.fill();
            
            ctx.restore();
        }

        // 初始化游戏
        window.addEventListener('load', function() {
            initGame();
        });
    </script>
</body>
</html>